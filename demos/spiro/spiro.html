<!doctype html>
<html>
<head>
<script src="spiro.js"></script>
<style>
	html,body,svg{
		margin:0;
		height:100%;
	}
	svg{
		width:100%;
		background-color:#222;
	}
	path{
		fill:none;
	}
	#pathA{
		stroke:red;
		stroke-opacity:1;
		stroke-width:1px;
	}
	#pathB{
		stroke:white;
		stroke-width:5px;
		marker-mid:url(#C-marker);
	}
	marker{
		stroke:cyan;
		stroke-width:0.3px;
		stroke-opacity:0.5;
		overflow:visible;
	}
</style>
</head>
<body>
<svg>
	<defs>
		<marker id="C-marker" orient="auto">
			<path d="M 0 0 L 0 10" transform="translate(0 ,-5)"/>
		</marker>
	</defs>
	<path id="pathA" d="M 0,0,100,100"/>
	<path id="pathB" d="M 0,0,100,100"/>
</svg>
<script>
// define base path
demoPath = [[50,100],[100,50],[300,200],[350.5,128],[350.5,250]];
var pathBEl = document.getElementById('pathB')
var i;
var starting = true; // boolean to tell first recursive seg_to_bez_svg that the process is starting
function update(){
	console.clear();
	var demoSolver;
	var my_d = ['M'];
	for(i=0; i<demoPath.length; i++){
		my_d.push(demoPath[i][0]);
		my_d.push(demoPath[i][1]);
	}
	var pathAEl = document.getElementById('pathA').setAttributeNS(null,'d',my_d.join(' '));
		// refine the curve
	var step = 1;
	for (var outer = 0; outer < 3; outer += 1) {
		demoSolver = setup_solver(demoPath);
		if (outer == 2) break;
		try {
			for (var j = 0; j < 30; j += 1){
				var refined = refine_euler(demoSolver, step);
				if (refined < 1e-6) break;
			}
			if (j < 30) break;
		} catch (error) {
			console.error(error);
		}
		step *= 0.5;
	}

	// convert spiro to bezier
	var spiro_d = ['M',demoPath[0][0],demoPath[0][1]];
	starting = true;
	for(i=0; i<demoSolver.segs.length; i++){
		console.group('segment',i);
		var seg = demoSolver.segs[i];
		var ths = seg.get_ths();
		var ks = fit_euler(ths[0], ths[1]).ks;
		ks.push(0,0);
		bez_data = [];
		spiro_d = spiro_d.concat(seg_to_bez_svg(ks, seg.left.xy[0], seg.left.xy[1], seg.right.xy[0], seg.right.xy[1]));
		console.groupEnd();
	}
	pathBEl.setAttributeNS(null,'d',spiro_d.join(' '));
}
	update();
window.onmousemove = function(event){
	demoPath[1] = [event.x || event.clientX , event.y || event.clientY];
	update();
};

function drift(){
    var big_angle = Math.random()*Math.PI*2.0;
    for(var i=0; i< demoPath.length; i++){
        var angle = Math.random()*Math.PI*2.0;
        demoPath[i][0] += Math.cos(angle) + Math.cos(big_angle);
        demoPath[i][1] += Math.sin(angle) + Math.sin(big_angle);
    }
    update();
}

//var drifter = setInterval(drift,16);
</script>
</body>
</html>