<!doctype html>
<html>
<head>
<script src="spiro.js"></script>
<style>
	html,body,svg{
		margin:0;
		height:100%;
	}
	svg{
		width:100%;
		background-color:#222;
	}
	path,polyline{
		fill:none;
	}
	#referencePath{
		stroke:red;
		stroke-width:1px;
	}
	#arc{
		stroke:yellow;
		stroke-width:1px;
	}
	#spiro{
		stroke:white;
		stroke-width:5px;
		marker-mid:url(#C-marker);
	}
	marker{
		stroke:cyan;
		stroke-width:0.3px;
		stroke-opacity:0.5;
		overflow:visible;
	}
</style>
</head>
<body>
<svg>
	<defs>
		<marker id="C-marker" orient="auto">
			<path d="M 0 0 L 0 10" transform="translate(0 ,-5)"/>
		</marker>
	</defs>
	<polyline id="referencePath" points="0,0,100,100"/>
	<path id="spiro" d="M 0,0,100,100"/>
	<path id="arc" d=""/>
</svg>
<script>
// define base path
demoPath = [[300,150],[300,300]];

var referencePath = document.getElementById('referencePath')
var spiroPath = document.getElementById('spiro');
var arcPath = document.getElementById('arc');
var i;

function update(){

	// remove doubles
	cleanedData = [];
	referenceData = [];
	var lastNonZeroDistancePoint = [];
	for(i=0; i<demoPath.length; i++){
		if((lastNonZeroDistancePoint.length !== 0)
		&&((demoPath[i][0] === lastNonZeroDistancePoint[0])
		&& (demoPath[i][1] === lastNonZeroDistancePoint[1]))){
			// do nothing
		}else{
			cleanedData.push(demoPath[i]);
			referenceData.push(demoPath[i][0]);
			referenceData.push(demoPath[i][1]);
			lastNonZeroDistancePoint = demoPath[i];
		}
	}

	// update reference line
	referencePath.setAttributeNS(null,'points',cleanedData.join(','));

	// update spiro
	if(cleanedData.length >= 2){
		var spiro_d = ['M',cleanedData[0][0],cleanedData[0][1]];
	}
	if(cleanedData.length === 2){
		spiro_d.push('L',cleanedData[1][0],cleanedData[1][1]);
	}
	if(cleanedData.length >= 3){
		var demoSolver;
		var step = 1;
		for (var outer = 0; outer < 3; outer += 1) {
			demoSolver = setup_solver(cleanedData);
			if (outer == 2) break;
			try {
				for (var j = 0; j < 30; j += 1){
					var refined = refine_euler(demoSolver, step);
					if (refined < 1e-6) break;
				}
				if (j < 30) break;
			} catch (error) {
				console.error(error);
			}
			step *= 0.5;
		}

		// convert spiro to bezier
		for(i=0; i<demoSolver.segs.length; i++){
			var seg = demoSolver.segs[i];
			var ths = seg.get_ths();
			var ks = fit_euler(ths[0], ths[1]).ks;
			ks.push(0,0);
			bez_data = [];
			spiro_d = spiro_d.concat(seg_to_bez_svg(ks, seg.left.xy[0], seg.left.xy[1], seg.right.xy[0], seg.right.xy[1]));
		}
	}
	spiroPath.setAttributeNS(null,'d',spiro_d.join(' '));
}
update();

var x,y;
window.onmousemove = function(event){
	x = event.x;
	y = event.y;
	demoPath[demoPath.length-1] = [event.x || event.clientX , event.y || event.clientY];
	update();
};

window.onkeydown = function(event){
	console.log(event.keyCode);
	if(event.keyCode === 32){
		// spacebar
		drift();
	}else{
		demoPath.push([x,y]);
	}
	update();
};

function drift(){
    var big_angle = Math.random()*Math.PI*2.0;
    for(var i=0; i< demoPath.length; i++){
        var angle = Math.random()*Math.PI*2.0;
        demoPath[i][0] += Math.cos(angle) + Math.cos(big_angle);
        demoPath[i][1] += Math.sin(angle) + Math.sin(big_angle);
    }
    update();
}

//var drifter = setInterval(drift,16);
</script>
</body>
</html>